{
  "title": "WebhookLib Documentation",
  "version": "2.0.0",
  "sections": [
    {
      "id": "getting-started",
      "title": "Getting Started",
      "content": "WebhookLib is a production-quality Discord webhook library for Roblox Server environments. It provides a complete suite of features for sending Discord webhook messages with automatic sanitization, rate limiting, error handling, and much more.",
      "subsections": [
        {
          "title": "Installation",
          "content": "1. Place the WebhookLib ModuleScript in ReplicatedStorage\n2. Name it \"WebhookLib\"\n3. Ensure your game has \"Allow HTTP Requests\" enabled in Game Settings > Security\n4. DataStore API access should be enabled (usually default)\n\n```lua\nlocal WebhookLib = require(game.ReplicatedStorage.WebhookLib)\n```"
        },
        {
          "title": "Required Game Settings",
          "content": "Before using WebhookLib, you must configure your Roblox game:\n\n1. Go to Game Settings > Security tab\n2. Enable \"Allow HTTP Requests\" - This is REQUIRED\n3. Ensure DataStore API access is enabled\n4. For testing, consider enabling Studio API access"
        },
        {
          "title": "Discord Webhook Setup",
          "content": "To get a Discord webhook URL:\n\n1. In your Discord server: Server Settings > Integrations > Webhooks\n2. Click \"Create Webhook\"\n3. Set name, avatar, and target channel\n4. Copy the webhook URL\n5. **IMPORTANT**: Use a proxy service like https://webhook.lewisakura.moe/ to convert your Discord URL for Roblox compatibility\n6. Paste your Discord URL into the proxy converter\n7. Use the converted URL in your Roblox script"
        },
        {
          "title": "Basic Usage",
          "content": "```lua\n-- Minimal setup\nlocal WebhookLib = require(game.ReplicatedStorage.WebhookLib)\nlocal webhook = WebhookLib.new(\"YOUR_WEBHOOK_URL\")\n\n-- Send a simple message\nwebhook:SendMessage(\"Hello from Roblox!\")\n\n-- Send an embed\nwebhook:SendEmbed({\n    title = \"Game Event\",\n    description = \"Something happened!\",\n    color = 0x00ff00\n})\n```"
        }
      ]
    },
    {
      "id": "configuration",
      "title": "Configuration",
      "content": "WebhookLib offers extensive configuration options to customize behavior. All options are optional and have sensible defaults.",
      "subsections": [
        {
          "title": "Basic Configuration",
          "content": "```lua\nlocal webhook = WebhookLib.new(\"YOUR_URL\", {\n    username = \"My Game Bot\",\n    avatar_url = \"https://example.com/avatar.png\",\n    default_color = 0x0099ff,\n    debug = true\n})\n```\n\n**Available Options:**\n- `username`: Default webhook username\n- `avatar_url`: Default webhook avatar\n- `default_color`: Default embed color (hex number)\n- `debug`: Enable debug logging (boolean)"
        },
        {
          "title": "Queue System",
          "content": "The queue system prevents Discord rate limiting and ensures reliable message delivery:\n\n```lua\n-- Enable queue without rate limiting\nlocal webhook = WebhookLib.new(\"YOUR_URL\", {\n    queue_enabled = true\n})\n\n-- Enable queue with rate limiting\nlocal webhook = WebhookLib.new(\"YOUR_URL\", {\n    queue_rate_limit = 2  -- 2 requests per second\n})\n```\n\n**Queue Options:**\n- `queue_enabled`: Enable request queueing\n- `queue_rate_limit`: Requests per second limit (auto-enables queue)\n- `max_retries`: Maximum retry attempts (default: 3)\n- `retry_backoff_base`: Base delay for exponential backoff"
        },
        {
          "title": "Message Tracking",
          "content": "Enable message ID tracking to edit and delete messages later:\n\n```lua\nlocal webhook = WebhookLib.new(\"YOUR_URL\", {\n    track_message_ids = true,\n    max_stored_messages = 100\n})\n```\n\n**Tracking Options:**\n- `track_message_ids`: Store message IDs for editing/deleting\n- `max_stored_messages`: Maximum number of IDs to store"
        },
        {
          "title": "Content Filtering",
          "content": "Built-in profanity filtering with customizable word lists:\n\n```lua\nlocal webhook = WebhookLib.new(\"YOUR_URL\", {\n    filter_profanity = true,\n    banned_words = {\"custom\", \"bad\", \"words\"}\n})\n```\n\n**Filter Options:**\n- `filter_profanity`: Enable profanity filtering\n- `banned_words`: Additional words to filter (array)"
        },
        {
          "title": "DataStore Settings",
          "content": "Configure DataStore integration for join count tracking:\n\n```lua\nlocal webhook = WebhookLib.new(\"YOUR_URL\", {\n    datastore_name = \"MyGame_WebhookData\",\n    cache_ttl_avatar = 300  -- 5 minutes\n})\n```\n\n**DataStore Options:**\n- `datastore_name`: Name for the DataStore\n- `cache_ttl_avatar`: Avatar cache TTL in seconds"
        }
      ]
    },
    {
      "id": "basic-messaging",
      "title": "Basic Messaging",
      "content": "WebhookLib supports various types of messages, from simple text to rich embeds with automatic content sanitization.",
      "subsections": [
        {
          "title": "Text Messages",
          "content": "Send simple text messages with optional customization:\n\n```lua\n-- Basic message\nwebhook:SendMessage(\"Hello Discord!\")\n\n-- With custom username and avatar\nwebhook:SendMessage(\"Custom message\", {\n    username = \"Custom Bot\",\n    avatar_url = \"https://example.com/avatar.png\"\n})\n```\n\n**Parameters:**\n- `content` (string): Message content (required)\n- `overrides` (table): Username and avatar overrides (optional)\n- `threadId` (string): Target thread ID (optional)"
        },
        {
          "title": "Embed Messages",
          "content": "Create rich embed messages with titles, descriptions, fields, and more:\n\n```lua\nwebhook:SendEmbed({\n    title = \"Game Statistics\",\n    description = \"Current server stats\",\n    color = 0x0099ff,\n    fields = {\n        {\n            name = \"Players Online\",\n            value = \"15/20\",\n            inline = true\n        },\n        {\n            name = \"Server Uptime\",\n            value = \"2 hours\",\n            inline = true\n        }\n    },\n    thumbnail = {\n        url = \"https://example.com/icon.png\"\n    },\n    footer = {\n        text = \"Game Statistics\",\n        icon_url = \"https://example.com/footer.png\"\n    },\n    timestamp = os.date(\"!%Y-%m-%dT%H:%M:%SZ\")\n})\n```"
        },
        {
          "title": "Multiple Embeds",
          "content": "Send up to 10 embeds in a single message:\n\n```lua\nlocal embeds = {\n    {\n        title = \"Embed 1\",\n        description = \"First embed\",\n        color = 0xff0000\n    },\n    {\n        title = \"Embed 2\",\n        description = \"Second embed\",\n        color = 0x00ff00\n    }\n}\n\nwebhook:SendMultipleEmbeds(embeds)\n```\n\n**Note:** Discord limits messages to 10 embeds maximum."
        },
        {
          "title": "Content Limits",
          "content": "WebhookLib automatically handles Discord's content limits:\n\n- **Message content**: 2,000 characters\n- **Embed title**: 256 characters\n- **Embed description**: 4,096 characters\n- **Field values**: 1,024 characters\n- **Footer text**: 2,048 characters\n- **Author name**: 256 characters\n- **Embeds per message**: 10 maximum\n\nContent exceeding limits is automatically truncated with \"...\" suffix."
        }
      ]
    },
    {
      "id": "thread-support",
      "title": "Thread Support",
      "content": "WebhookLib fully supports Discord threads, allowing you to send messages directly to specific thread channels.",
      "subsections": [
        {
          "title": "Thread Messages",
          "content": "Send messages to specific Discord threads:\n\n```lua\nlocal THREAD_ID = \"123456789012345678\"\n\n-- Direct thread methods\nwebhook:SendMessageInThread(\"Hello thread!\", THREAD_ID)\n\nwebhook:SendEmbedInThread({\n    title = \"Thread Update\",\n    description = \"This message goes to a specific thread\"\n}, THREAD_ID)\n```"
        },
        {
          "title": "Alternative Thread Syntax",
          "content": "Use the optional threadId parameter with regular methods:\n\n```lua\nlocal THREAD_ID = \"123456789012345678\"\n\n-- Using optional threadId parameter\nwebhook:SendMessage(\"Thread message\", nil, THREAD_ID)\n\nwebhook:SendEmbed({\n    title = \"Thread Embed\"\n}, THREAD_ID)\n\nwebhook:SendMultipleEmbeds(embedsArray, THREAD_ID)\n```"
        },
        {
          "title": "Getting Thread IDs",
          "content": "To find Discord thread IDs:\n\n1. **In Discord Web/Desktop:**\n   - Right-click on the thread name\n   - Select \"Copy Thread ID\"\n   - (Developer Mode must be enabled)\n\n2. **From URL:**\n   - Thread URLs contain the ID: `discord.com/channels/SERVER/CHANNEL/THREAD_ID`\n   - The last number is the thread ID\n\n3. **Enable Developer Mode:**\n   - User Settings > Advanced > Developer Mode"
        },
        {
          "title": "Thread Best Practices",
          "content": "**Organizing Messages:**\n- Use different threads for different event types\n- Create dedicated threads for player events, errors, etc.\n- Use descriptive thread names\n\n```lua\n-- Example: Separate threads for different purposes\nlocal PLAYER_EVENTS_THREAD = \"111111111111111111\"\nlocal ERROR_LOG_THREAD = \"222222222222222222\"\nlocal GAME_EVENTS_THREAD = \"333333333333333333\"\n\n-- Player joins go to player events thread\nwebhook:SendJoinMessage(player, PLAYER_EVENTS_THREAD)\n\n-- Errors go to error thread\nwebhook:SendMessage(\"Error occurred!\", nil, ERROR_LOG_THREAD)\n```"
        }
      ]
    },
    {
      "id": "message-management",
      "title": "Message Management",
      "content": "Edit and delete webhook messages using message ID tracking. This feature requires enabling message tracking in configuration.",
      "subsections": [
        {
          "title": "Enabling Message Tracking",
          "content": "First, enable message ID tracking:\n\n```lua\nlocal webhook = WebhookLib.new(\"YOUR_URL\", {\n    track_message_ids = true,\n    max_stored_messages = 100\n})\n\n-- Or enable at runtime\nwebhook:EnableMessageTracking(true)\n```\n\n**Important Notes:**\n- Message tracking stores IDs in memory\n- IDs are lost when the server restarts\n- Only the most recent messages are tracked"
        },
        {
          "title": "Editing Messages",
          "content": "Edit message content and embeds:\n\n```lua\n-- Edit text content\nwebhook:EditMessage(messageId, \"New message content\")\n\n-- Edit with embed only\nwebhook:EditMessage(messageId, nil, {\n    title = \"Updated Embed\",\n    color = 0xff0000\n})\n\n-- Edit both content and embed\nwebhook:EditMessage(messageId, \"Updated text\", {\n    title = \"Updated Embed\",\n    description = \"Both content and embed updated\"\n})\n\n-- Edit with multiple embeds\nwebhook:EditMessage(messageId, \"Text\", {\n    {title = \"Embed 1\"},\n    {title = \"Embed 2\"}\n})\n```"
        },
        {
          "title": "Deleting Messages",
          "content": "Delete webhook messages:\n\n```lua\n-- Delete by message ID\nwebhook:DeleteMessage(messageId)\n```\n\n**Note:** Deleted messages are automatically removed from the stored message ID list."
        },
        {
          "title": "Working with Message IDs",
          "content": "Get and manage stored message IDs:\n\n```lua\n-- Get the latest message ID\nlocal latestId = webhook:GetLatestMessageId()\nif latestId then\n    webhook:EditMessage(latestId, \"Updated latest message\")\nend\n\n-- Get all stored messages\nlocal messages = webhook:GetStoredMessages()\nfor _, msg in ipairs(messages) do\n    print(\"ID:\", msg.id)\n    print(\"Type:\", msg.metadata.type)\n    print(\"Timestamp:\", msg.timestamp)\nend\n\n-- Clear stored message IDs\nwebhook:ClearStoredMessages()\n```"
        },
        {
          "title": "Message ID Workflow",
          "content": "Typical workflow for message management:\n\n```lua\n-- 1. Send a message\nwebhook:SendMessage(\"Status: Starting...\")\n\n-- 2. Wait for it to be sent and tracked\ntask.wait(2)\n\n-- 3. Get the message ID\nlocal statusMessageId = webhook:GetLatestMessageId()\n\n-- 4. Update the message as needed\nif statusMessageId then\n    webhook:EditMessage(statusMessageId, \"Status: In Progress...\")\n    \n    -- Later...\n    task.wait(10)\n    webhook:EditMessage(statusMessageId, \"Status: Complete!\")\nend\n```"
        }
      ]
    },
    {
      "id": "player-events",
      "title": "Player Events",
      "content": "Automatically track and announce player joins/leaves with rich information and avatar thumbnails.",
      "subsections": [
        {
          "title": "Player Join Messages",
          "content": "Send detailed join notifications:\n\n```lua\n-- Basic join message\nwebhook:SendJoinMessage(player)\n\n-- Join message in specific thread\nlocal PLAYER_THREAD = \"123456789012345678\"\nwebhook:SendJoinMessage(player, PLAYER_THREAD)\n\n-- Connect to PlayerAdded event\ngame.Players.PlayerAdded:Connect(function(player)\n    pcall(function()\n        webhook:SendJoinMessage(player)\n    end)\nend)\n```\n\n**Join messages include:**\n- Player avatar thumbnail\n- Username and display name\n- User ID\n- Join count (tracked in DataStore)\n- Current player count\n- Account age\n- Timestamp"
        },
        {
          "title": "Player Leave Messages",
          "content": "Send leave notifications:\n\n```lua\n-- Basic leave message\nwebhook:SendLeaveMessage(player)\n\n-- Leave message in specific thread\nwebhook:SendLeaveMessage(player, PLAYER_THREAD)\n\n-- Connect to PlayerRemoving event\ngame.Players.PlayerRemoving:Connect(function(player)\n    pcall(function()\n        webhook:SendLeaveMessage(player)\n    end)\nend)\n```\n\n**Leave messages include:**\n- Player avatar thumbnail\n- Username and display name\n- Total join count\n- Remaining player count\n- Timestamp"
        },
        {
          "title": "Complete Player Tracking",
          "content": "Set up comprehensive player event tracking:\n\n```lua\nlocal WebhookLib = require(game.ReplicatedStorage.WebhookLib)\nlocal webhook = WebhookLib.new(\"YOUR_URL\", {\n    username = \"ðŸŽ® Player Tracker\",\n    debug = false,\n    queue_rate_limit = 2,\n    datastore_name = \"PlayerTracking\"\n})\n\nlocal PLAYER_THREAD = \"123456789012345678\"\n\n-- Player joined\ngame.Players.PlayerAdded:Connect(function(player)\n    pcall(function()\n        webhook:SendJoinMessage(player, PLAYER_THREAD)\n    end)\nend)\n\n-- Player left\ngame.Players.PlayerRemoving:Connect(function(player)\n    pcall(function()\n        webhook:SendLeaveMessage(player, PLAYER_THREAD)\n    end)\nend)\n\n-- Server startup message\nwebhook:SendMessage(\"ðŸš€ Server started! Players: \" .. #game.Players:GetPlayers())\n```"
        },
        {
          "title": "Avatar System",
          "content": "WebhookLib automatically fetches and caches player avatars:\n\n**Features:**\n- Automatic avatar fetching from Roblox API\n- Memory caching with configurable TTL\n- Fallback to default avatar on failure\n- Thread-safe operations\n\n**Configuration:**\n```lua\nlocal webhook = WebhookLib.new(\"YOUR_URL\", {\n    cache_ttl_avatar = 600,  -- Cache for 10 minutes\n    avatar_url = \"https://example.com/default.png\"  -- Fallback\n})\n```"
        },
        {
          "title": "Join Count Tracking",
          "content": "Automatic join count tracking with DataStore persistence:\n\n**Features:**\n- Persistent join counts across server restarts\n- Memory caching for performance\n- Automatic retry logic for DataStore failures\n- Thread-safe increment operations\n\n**How it works:**\n1. Player joins â†’ Count retrieved from DataStore\n2. Count incremented and cached in memory\n3. Updated count saved to DataStore\n4. Join message shows total join count\n\n**DataStore Structure:**\n- Key: `\"joins_\" .. userId`\n- Value: Number of times player has joined"
        }
      ]
    },
    {
      "id": "custom-events",
      "title": "Custom Events",
      "content": "Create custom event notifications with structured data display.",
      "subsections": [
        {
          "title": "Basic Custom Events",
          "content": "Send custom event notifications:\n\n```lua\n-- Simple event\nwebhook:SendCustomEvent(\"Player Achievement\", {\n    Player = \"john_doe\",\n    Achievement = \"First Victory!\",\n    Score = \"9,999\"\n})\n\n-- Event in thread\nlocal EVENT_THREAD = \"123456789012345678\"\nwebhook:SendCustomEvent(\"Server Event\", {\n    Type = \"Boss Defeated\",\n    Players = \"5\",\n    Duration = \"10 minutes\"\n}, EVENT_THREAD)\n```"
        },
        {
          "title": "Event Data Structure",
          "content": "Custom events automatically format data as embed fields:\n\n```lua\n-- Data becomes embed fields\nlocal eventData = {\n    [\"ðŸŽ¯ Target\"] = \"Epic Boss\",\n    [\"âš”ï¸ Damage Dealt\"] = \"50,000\",\n    [\"ðŸ† Reward\"] = \"Legendary Sword\",\n    [\"â° Time Taken\"] = \"5:32\",\n    [\"ðŸ‘¥ Party Size\"] = \"4 players\"\n}\n\nwebhook:SendCustomEvent(\"ðŸ‰ Boss Battle Complete\", eventData)\n```\n\n**Formatting Rules:**\n- Up to 25 fields maximum\n- Keys become field names\n- Values become field values\n- All fields are inline by default\n- Content is automatically sanitized"
        },
        {
          "title": "Game Event Examples",
          "content": "Common game event patterns:\n\n```lua\n-- Player milestone\nwebhook:SendCustomEvent(\"ðŸŽ‰ Player Milestone\", {\n    [\"Player\"] = player.DisplayName,\n    [\"Milestone\"] = \"Level 50 Reached\",\n    [\"Play Time\"] = \"15 hours\",\n    [\"Next Goal\"] = \"Level 75\"\n})\n\n-- Economic event\nwebhook:SendCustomEvent(\"ðŸ’° Rare Item Sale\", {\n    [\"Item\"] = \"Dragon Sword\",\n    [\"Price\"] = \"10,000 coins\",\n    [\"Seller\"] = \"player123\",\n    [\"Buyer\"] = \"player456\"\n})\n\n-- Server milestone\nwebhook:SendCustomEvent(\"ðŸ“Š Server Milestone\", {\n    [\"Milestone\"] = \"1000 Total Players\",\n    [\"Current Online\"] = \"50\",\n    [\"Peak Today\"] = \"75\",\n    [\"Uptime\"] = \"12 hours\"\n})\n```"
        },
        {
          "title": "Advanced Event Formatting",
          "content": "Create more complex event notifications:\n\n```lua\n-- Function to format event data\nlocal function formatGameEvent(eventType, data)\n    local emoji = {\n        achievement = \"ðŸ†\",\n        combat = \"âš”ï¸\",\n        economic = \"ðŸ’°\",\n        social = \"ðŸ‘¥\"\n    }\n    \n    local title = (emoji[eventType] or \"ðŸ””\") .. \" \" .. (data.title or \"Game Event\")\n    \n    -- Remove title from data to avoid duplication\n    local eventData = {}\n    for key, value in pairs(data) do\n        if key ~= \"title\" then\n            eventData[key] = value\n        end\n    end\n    \n    return title, eventData\nend\n\n-- Usage\nlocal title, data = formatGameEvent(\"achievement\", {\n    title = \"New High Score!\",\n    Player = \"speedrunner99\",\n    Score = \"999,999\",\n    Previous = \"875,000\",\n    Improvement = \"+124,999\"\n})\n\nwebhook:SendCustomEvent(title, data)\n```"
        }
      ]
    },
    {
      "id": "error-handling",
      "title": "Error Handling & Reliability",
      "content": "WebhookLib includes comprehensive error handling, retry logic, and reliability features for production use.",
      "subsections": [
        {
          "title": "Automatic Retry Logic",
          "content": "Built-in retry system with exponential backoff:\n\n```lua\nlocal webhook = WebhookLib.new(\"YOUR_URL\", {\n    max_retries = 5,\n    retry_backoff_base = 2  -- seconds\n})\n```\n\n**Retry Behavior:**\n- Automatic retries for network failures\n- Exponential backoff: 2s, 4s, 8s, 16s, 32s\n- Maximum backoff capped at 60 seconds\n- Discord rate limits handled separately\n- Server errors (5xx) trigger retries\n- Client errors (4xx) don't retry"
        },
        {
          "title": "Rate Limit Handling",
          "content": "Automatic Discord rate limit detection and handling:\n\n**Features:**\n- Detects 429 (Too Many Requests) responses\n- Parses retry-after headers\n- Automatically delays and retries\n- Prevents request loss\n- Caps delays at 5 minutes for safety\n\n```lua\n-- Rate limiting handled automatically\nlocal webhook = WebhookLib.new(\"YOUR_URL\", {\n    queue_rate_limit = 2,  -- Prevent rate limits\n    debug = true  -- See rate limit messages\n})\n```"
        },
        {
          "title": "Production Error Handling",
          "content": "Recommended error handling patterns:\n\n```lua\n-- Wrap webhook calls in pcall\nlocal function safeWebhookCall(func, ...)\n    local success, result = pcall(func, ...)\n    if not success then\n        warn(\"Webhook call failed:\", result)\n        return false\n    end\n    return result\nend\n\n-- Usage examples\nsafeWebhookCall(webhook.SendMessage, webhook, \"Safe message\")\nsafeWebhookCall(webhook.SendJoinMessage, webhook, player)\n\n-- Or use inline pcall\npcall(function()\n    webhook:SendMessage(\"This won't crash the server\")\nend)\n```"
        },
        {
          "title": "Debug Logging",
          "content": "Enable debug mode for troubleshooting:\n\n```lua\nlocal webhook = WebhookLib.new(\"YOUR_URL\", {\n    debug = true\n})\n\n-- Or enable at runtime\nwebhook:EnableDebug(true)\n```\n\n**Debug Output Includes:**\n- Initialization status\n- Queue operations\n- HTTP request/response details\n- Rate limit information\n- DataStore operations\n- Error messages and stack traces\n- Message ID tracking events"
        },
        {
          "title": "Graceful Shutdown",
          "content": "Proper shutdown handling for server restarts:\n\n```lua\n-- Graceful shutdown\ngame:BindToClose(function()\n    if webhook then\n        print(\"Shutting down webhook...\")\n        \n        -- Send final message\n        pcall(function()\n            webhook:SendMessage(\"ðŸ”„ Server restarting...\")\n        end)\n        \n        -- Wait for pending requests\n        webhook:Shutdown()\n        task.wait(3)  -- Allow time for final requests\n        \n        print(\"Webhook shutdown complete\")\n    end\nend)\n```"
        },
        {
          "title": "Common Issues & Solutions",
          "content": "**HTTP Requests Disabled:**\n```\n[WebhookLib] ERROR: HTTP requests are disabled\n```\n*Solution: Enable \"Allow HTTP Requests\" in Game Settings*\n\n**DataStore Unavailable:**\n```\n[WebhookLib] DataStore: UNAVAILABLE\n```\n*Solution: Check DataStore API access in game settings*\n\n**Invalid Webhook URL:**\n```\nHTTP 404 (Not Found)\n```\n*Solution: Verify webhook URL and use proxy for Roblox compatibility*\n\n**Rate Limited:**\n```\nDiscord rate limit detected, retrying after X seconds\n```\n*Solution: Enable queue system with rate limiting*"
        }
      ]
    },
    {
      "id": "queue-system",
      "title": "Queue System",
      "content": "The queue system prevents Discord rate limiting and ensures reliable message delivery through request queuing and rate limiting.",
      "subsections": [
        {
          "title": "Queue Modes",
          "content": "Three different queue operating modes:\n\n```lua\n-- 1. No Queue (Default) - Immediate sending\nlocal webhook = WebhookLib.new(\"YOUR_URL\")\n-- Messages sent immediately, no queuing\n\n-- 2. Queue Only - No rate limiting\nlocal webhook = WebhookLib.new(\"YOUR_URL\", {\n    queue_enabled = true\n})\n-- Messages queued but sent as fast as possible\n\n-- 3. Queue + Rate Limiting - Recommended\nlocal webhook = WebhookLib.new(\"YOUR_URL\", {\n    queue_rate_limit = 2  -- 2 requests per second\n})\n-- Messages queued and rate limited\n```"
        },
        {
          "title": "Rate Limiting Configuration",
          "content": "Configure rate limits based on your needs:\n\n```lua\n-- Conservative (1 message per second)\nlocal webhook = WebhookLib.new(\"YOUR_URL\", {\n    queue_rate_limit = 1\n})\n\n-- Moderate (2 messages per second) - Recommended\nlocal webhook = WebhookLib.new(\"YOUR_URL\", {\n    queue_rate_limit = 2\n})\n\n-- Aggressive (5 messages per second)\nlocal webhook = WebhookLib.new(\"YOUR_URL\", {\n    queue_rate_limit = 5\n})\n```\n\n**Recommendation:** Start with 2 requests/second for most games."
        },
        {
          "title": "Queue Management",
          "content": "Monitor and control the queue system:\n\n```lua\n-- Check queue status\nprint(\"Queue enabled:\", webhook:IsQueueEnabled())\nprint(\"Queue size:\", webhook:GetQueueSize())\n\n-- Enable/disable queue at runtime\nwebhook:EnableQueue(true, 2)  -- Enable with 2 req/sec\nwebhook:EnableQueue(false)    -- Disable queue\n\n-- Monitor queue in real-time\ntask.spawn(function()\n    while true do\n        if webhook:GetQueueSize() > 0 then\n            print(\"Queue size:\", webhook:GetQueueSize())\n        end\n        task.wait(5)\n    end\nend)\n```"
        },
        {
          "title": "Queue Priority",
          "content": "Understanding message priority in the queue:\n\n**Normal Priority:**\n- Regular messages\n- Embeds\n- Custom events\n- Player notifications\n\n**High Priority (Front of Queue):**\n- Rate limit retries\n- Failed request retries\n- Discord-requested delays\n\n```lua\n-- All these messages use normal priority\nwebhook:SendMessage(\"Normal message\")\nwebhook:SendEmbed({title = \"Normal embed\"})\nwebhook:SendJoinMessage(player)\n\n-- Rate limited messages automatically get priority\n```"
        },
        {
          "title": "Queue Performance",
          "content": "Queue system performance characteristics:\n\n**Memory Usage:**\n- Each queued request: ~1KB memory\n- Large queues (1000+ messages): Monitor memory\n- Old requests automatically cleaned up\n\n**Processing Speed:**\n- Queue check interval: 100ms\n- Rate limit precision: Â±50ms\n- Background processing (non-blocking)\n\n**Best Practices:**\n- Monitor queue size in high-traffic games\n- Use rate limiting to prevent buildup\n- Consider message importance vs. volume"
        },
        {
          "title": "Queue vs No Queue",
          "content": "When to use each approach:\n\n**Use No Queue When:**\n- Low message volume (<10/minute)\n- Immediate delivery required\n- Simple games with few players\n- Testing and development\n\n**Use Queue When:**\n- High message volume\n- Many simultaneous events\n- Production games with many players\n- Reliability is critical\n\n**Use Queue + Rate Limiting When:**\n- Risk of Discord rate limits\n- Consistent message delivery needed\n- Professional/commercial games\n- Player events are frequent"
        }
      ]
    },
    {
      "id": "api-reference",
      "title": "API Reference",
      "content": "Complete reference for all WebhookLib methods, parameters, and return values.",
      "subsections": [
        {
          "title": "Constructor",
          "content": "**WebhookLib.new(url, options)**\n\nCreates a new WebhookLib instance.\n\n**Parameters:**\n- `url` (string, required): Discord webhook URL\n- `options` (table, optional): Configuration options\n\n**Returns:**\n- WebhookLib instance\n\n**Example:**\n```lua\nlocal webhook = WebhookLib.new(\"https://webhook.url\", {\n    username = \"Bot Name\",\n    debug = true\n})\n```\n\n**Configuration Options:**\n- `username`: Default webhook username\n- `avatar_url`: Default webhook avatar URL\n- `default_color`: Default embed color (number)\n- `queue_enabled`: Enable request queueing (boolean)\n- `queue_rate_limit`: Rate limit (requests/second)\n- `max_retries`: Maximum retry attempts (number)\n- `retry_backoff_base`: Retry backoff base delay (seconds)\n- `debug`: Enable debug logging (boolean)\n- `filter_profanity`: Enable profanity filtering (boolean)\n- `banned_words`: Custom banned words array\n- `track_message_ids`: Enable message ID tracking (boolean)\n- `max_stored_messages`: Maximum stored message IDs\n- `datastore_name`: DataStore name for join counts\n- `cache_ttl_avatar`: Avatar cache TTL (seconds)"
        },
        {
          "title": "Basic Messaging Methods",
          "content": "**SendMessage(content, overrides, threadId)**\n\nSends a text message to Discord.\n\n**Parameters:**\n- `content` (string, required): Message content\n- `overrides` (table, optional): Username/avatar overrides\n- `threadId` (string, optional): Target thread ID\n\n**Returns:** boolean (success)\n\n---\n\n**SendEmbed(embedTable, threadId)**\n\nSends an embed message to Discord.\n\n**Parameters:**\n- `embedTable` (table, required): Discord embed object\n- `threadId` (string, optional): Target thread ID\n\n**Returns:** boolean (success)\n\n---\n\n**SendMultipleEmbeds(embeds, threadId)**\n\nSends multiple embeds in one message.\n\n**Parameters:**\n- `embeds` (array, required): Array of embed objects\n- `threadId` (string, optional): Target thread ID\n\n**Returns:** boolean (success)"
        },
        {
          "title": "Thread-Specific Methods",
          "content": "**SendMessageInThread(content, threadId, overrides)**\n\nSends a message to a specific thread.\n\n**Parameters:**\n- `content` (string, required): Message content\n- `threadId` (string, required): Target thread ID\n- `overrides` (table, optional): Username/avatar overrides\n\n**Returns:** boolean (success)\n\n---\n\n**SendEmbedInThread(embedTable, threadId)**\n\nSends an embed to a specific thread.\n\n**Parameters:**\n- `embedTable` (table, required): Discord embed object\n- `threadId` (string, required): Target thread ID\n\n**Returns:** boolean (success)"
        },
        {
          "title": "Message Management Methods",
          "content": "**EditMessage(messageId, content, embeds)**\n\nEdits a webhook message.\n\n**Parameters:**\n- `messageId` (string, required): Discord message ID\n- `content` (string, optional): New message content\n- `embeds` (table/array, optional): New embed(s)\n\n**Returns:** boolean (success)\n\n---\n\n**DeleteMessage(messageId)**\n\nDeletes a webhook message.\n\n**Parameters:**\n- `messageId` (string, required): Discord message ID\n\n**Returns:** boolean (success)\n\n---\n\n**GetStoredMessages()**\n\nReturns all tracked message IDs.\n\n**Returns:** array of message objects\n\n---\n\n**GetLatestMessageId()**\n\nReturns the most recent message ID.\n\n**Returns:** string (message ID) or nil\n\n---\n\n**ClearStoredMessages()**\n\nClears all stored message IDs.\n\n**Returns:** void"
        },
        {
          "title": "Player Event Methods",
          "content": "**SendJoinMessage(player, threadId)**\n\nSends a player join notification.\n\n**Parameters:**\n- `player` (Player, required): Roblox Player instance\n- `threadId` (string, optional): Target thread ID\n\n**Returns:** boolean (success)\n\n---\n\n**SendLeaveMessage(player, threadId)**\n\nSends a player leave notification.\n\n**Parameters:**\n- `player` (Player, required): Roblox Player instance\n- `threadId` (string, optional): Target thread ID\n\n**Returns:** boolean (success)\n\n---\n\n**SendCustomEvent(name, data, threadId)**\n\nSends a custom event notification.\n\n**Parameters:**\n- `name` (string, required): Event name/title\n- `data` (table, optional): Event data (becomes embed fields)\n- `threadId` (string, optional): Target thread ID\n\n**Returns:** boolean (success)"
        },
        {
          "title": "Configuration Methods",
          "content": "**SetWebhookUrl(url)**\n\nUpdates the webhook URL.\n\n**Parameters:**\n- `url` (string, required): New webhook URL\n\n**Returns:** boolean (success)\n\n---\n\n**SetDefaultUsername(username)**\n\nSets the default webhook username.\n\n**Parameters:**\n- `username` (string, required): New username\n\n**Returns:** boolean (success)\n\n---\n\n**SetDefaultAvatarUrl(avatarUrl)**\n\nSets the default webhook avatar URL.\n\n**Parameters:**\n- `avatarUrl` (string, required): New avatar URL\n\n**Returns:** boolean (success)\n\n---\n\n**SetDefaultColor(color)**\n\nSets the default embed color.\n\n**Parameters:**\n- `color` (number, required): Hex color value (0x000000 to 0xFFFFFF)\n\n**Returns:** boolean (success)"
        },
        {
          "title": "Runtime Control Methods",
          "content": "**EnableDebug(enabled)**\n\nEnables or disables debug logging.\n\n**Parameters:**\n- `enabled` (boolean, required): Enable debug mode\n\n**Returns:** boolean (success)\n\n---\n\n**EnableQueue(enabled, rateLimit)**\n\nEnables or disables the queue system.\n\n**Parameters:**\n- `enabled` (boolean, required): Enable queue\n- `rateLimit` (number, optional): Requests per second\n\n**Returns:** boolean (success)\n\n---\n\n**EnableMessageTracking(enabled)**\n\nEnables or disables message ID tracking.\n\n**Parameters:**\n- `enabled` (boolean, required): Enable tracking\n\n**Returns:** boolean (success)\n\n---\n\n**Shutdown()**\n\nGracefully shuts down the webhook system.\n\n**Returns:** void"
        },
        {
          "title": "Status Methods",
          "content": "**GetQueueSize()**\n\nReturns the current queue size.\n\n**Returns:** number (queue size)\n\n---\n\n**IsQueueEnabled()**\n\nChecks if queue system is enabled.\n\n**Returns:** boolean (enabled)\n\n---\n\n**IsMessageTrackingEnabled()**\n\nChecks if message ID tracking is enabled.\n\n**Returns:** boolean (enabled)\n\n---\n\n**GetConfiguration()**\n\nReturns a copy of the current configuration.\n\n**Returns:** table (configuration copy)"
        }
      ]
    },
    {
      "id": "examples",
      "title": "Complete Examples",
      "content": "Real-world examples and implementation patterns for different use cases.",
      "subsections": [
        {
          "title": "Basic Game Bot",
          "content": "Simple setup for basic game notifications:\n\n```lua\n-- ServerScript in ServerScriptService\nlocal WebhookLib = require(game.ReplicatedStorage.WebhookLib)\n\n-- Basic setup\nlocal webhook = WebhookLib.new(\"YOUR_WEBHOOK_URL\", {\n    username = \"ðŸŽ® Game Bot\",\n    debug = false\n})\n\n-- Server startup\nwebhook:SendMessage(\"ðŸš€ Server started!\")\n\n-- Player events\ngame.Players.PlayerAdded:Connect(function(player)\n    webhook:SendJoinMessage(player)\nend)\n\ngame.Players.PlayerRemoving:Connect(function(player)\n    webhook:SendLeaveMessage(player)\nend)\n\n-- Server shutdown\ngame:BindToClose(function()\n    webhook:SendMessage(\"ðŸ”„ Server shutting down...\")\n    webhook:Shutdown()\nend)\n```"
        },
        {
          "title": "Production Game Setup",
          "content": "Advanced setup for production games:\n\n```lua\nlocal WebhookLib = require(game.ReplicatedStorage.WebhookLib)\nlocal Players = game:GetService(\"Players\")\n\n-- Production configuration\nlocal webhook = WebhookLib.new(\"YOUR_WEBHOOK_URL\", {\n    username = \"ðŸ† Epic Game\",\n    debug = false,  -- Disable in production\n    queue_rate_limit = 2,  -- 2 messages per second\n    filter_profanity = true,\n    track_message_ids = true,\n    max_stored_messages = 100,\n    max_retries = 5\n})\n\n-- Thread IDs for different purposes\nlocal THREADS = {\n    PLAYERS = \"111111111111111111\",\n    EVENTS = \"222222222222222222\",\n    ERRORS = \"333333333333333333\",\n    ADMIN = \"444444444444444444\"\n}\n\n-- Startup with server info\nlocal function sendStartupInfo()\n    local startupData = {\n        [\"ðŸ†” Place ID\"] = tostring(game.PlaceId),\n        [\"ðŸŽ® Game Name\"] = game.Name,\n        [\"ðŸ‘¥ Max Players\"] = tostring(game.Players.MaxPlayers),\n        [\"ðŸ• Started At\"] = os.date(\"%Y-%m-%d %H:%M:%S UTC\")\n    }\n    \n    webhook:SendCustomEvent(\"ðŸš€ Server Started\", startupData, THREADS.ADMIN)\nend\n\n-- Enhanced player tracking\ngame.Players.PlayerAdded:Connect(function(player)\n    pcall(function()\n        webhook:SendJoinMessage(player, THREADS.PLAYERS)\n        \n        -- VIP player notification\n        if player:GetAttribute(\"VIP\") then\n            webhook:SendCustomEvent(\"â­ VIP Player Joined\", {\n                [\"Player\"] = player.DisplayName,\n                [\"VIP Level\"] = player:GetAttribute(\"VIPLevel\") or \"Unknown\"\n            }, THREADS.ADMIN)\n        end\n    end)\nend)\n\ngame.Players.PlayerRemoving:Connect(function(player)\n    pcall(function()\n        webhook:SendLeaveMessage(player, THREADS.PLAYERS)\n    end)\nend)\n\n-- Error logging\nlocal function logError(errorMsg, context)\n    pcall(function()\n        webhook:SendCustomEvent(\"âŒ Server Error\", {\n            [\"Error\"] = tostring(errorMsg),\n            [\"Context\"] = tostring(context or \"Unknown\"),\n            [\"Server\"] = tostring(game.JobId),\n            [\"Time\"] = os.date(\"%H:%M:%S\")\n        }, THREADS.ERRORS)\n    end)\nend\n\n-- Initialize\nstartupInfo()\nprint(\"Production webhook system initialized\")\n```"
        },
        {
          "title": "Message Management System",
          "content": "System for managing persistent status messages:\n\n```lua\nlocal WebhookLib = require(game.ReplicatedStorage.WebhookLib)\n\nlocal webhook = WebhookLib.new(\"YOUR_WEBHOOK_URL\", {\n    track_message_ids = true,\n    queue_rate_limit = 1,\n    debug = true\n})\n\n-- Status message manager\nlocal StatusManager = {\n    messages = {},\n    webhook = webhook\n}\n\nfunction StatusManager:CreateStatus(key, initialContent)\n    -- Send initial status message\n    self.webhook:SendMessage(initialContent)\n    \n    -- Wait and store the message ID\n    task.wait(2)\n    local messageId = self.webhook:GetLatestMessageId()\n    \n    if messageId then\n        self.messages[key] = {\n            id = messageId,\n            lastContent = initialContent,\n            created = tick()\n        }\n        print(\"Created status message:\", key, \"ID:\", messageId)\n        return true\n    end\n    \n    return false\nend\n\nfunction StatusManager:UpdateStatus(key, newContent)\n    local status = self.messages[key]\n    if not status then\n        warn(\"Status message not found:\", key)\n        return false\n    end\n    \n    self.webhook:EditMessage(status.id, newContent)\n    status.lastContent = newContent\n    status.lastUpdated = tick()\n    \n    print(\"Updated status message:\", key)\n    return true\nend\n\nfunction StatusManager:DeleteStatus(key)\n    local status = self.messages[key]\n    if not status then\n        warn(\"Status message not found:\", key)\n        return false\n    end\n    \n    self.webhook:DeleteMessage(status.id)\n    self.messages[key] = nil\n    \n    print(\"Deleted status message:\", key)\n    return true\nend\n\n-- Usage example\nStatusManager:CreateStatus(\"server_info\", \"ðŸ”„ Server starting up...\")\n\ntask.wait(5)\nStatusManager:UpdateStatus(\"server_info\", \"âœ… Server running - Players: 0/20\")\n\n-- Update player count periodically\ntask.spawn(function()\n    while true do\n        local playerCount = #game.Players:GetPlayers()\n        local maxPlayers = game.Players.MaxPlayers\n        StatusManager:UpdateStatus(\"server_info\", \n            string.format(\"âœ… Server running - Players: %d/%d\", playerCount, maxPlayers))\n        task.wait(30)  -- Update every 30 seconds\n    end\nend)\n```"
        },
        {
          "title": "Multi-Thread Organization",
          "content": "Organize different message types into separate threads:\n\n```lua\nlocal WebhookLib = require(game.ReplicatedStorage.WebhookLib)\n\nlocal webhook = WebhookLib.new(\"YOUR_WEBHOOK_URL\", {\n    username = \"ðŸŽ® Multi-Thread Bot\",\n    queue_rate_limit = 3,\n    track_message_ids = true\n})\n\n-- Thread configuration\nlocal CHANNELS = {\n    -- Main channel threads\n    GENERAL = nil,  -- Main channel (no thread ID)\n    PLAYERS = \"123456789012345678\",\n    GAME_EVENTS = \"234567890123456789\",\n    ACHIEVEMENTS = \"345678901234567890\",\n    ERRORS = \"456789012345678901\",\n    \n    -- Admin channel threads\n    ADMIN_GENERAL = \"567890123456789012\",\n    SERVER_STATUS = \"678901234567890123\",\n    MODERATION = \"789012345678901234\"\n}\n\n-- Message routing system\nlocal MessageRouter = {\n    webhook = webhook,\n    channels = CHANNELS\n}\n\nfunction MessageRouter:SendToGeneral(content)\n    return self.webhook:SendMessage(content, nil, self.channels.GENERAL)\nend\n\nfunction MessageRouter:SendPlayerEvent(player, eventType)\n    if eventType == \"join\" then\n        return self.webhook:SendJoinMessage(player, self.channels.PLAYERS)\n    elseif eventType == \"leave\" then\n        return self.webhook:SendLeaveMessage(player, self.channels.PLAYERS)\n    end\nend\n\nfunction MessageRouter:SendGameEvent(eventName, data)\n    return self.webhook:SendCustomEvent(eventName, data, self.channels.GAME_EVENTS)\nend\n\nfunction MessageRouter:SendAchievement(player, achievement)\n    local data = {\n        [\"ðŸ† Player\"] = player.DisplayName,\n        [\"ðŸŽ¯ Achievement\"] = achievement.name,\n        [\"ðŸ’Ž Rarity\"] = achievement.rarity or \"Common\",\n        [\"ðŸ“… Date\"] = os.date(\"%Y-%m-%d\"),\n        [\"â° Time\"] = os.date(\"%H:%M:%S\")\n    }\n    return self.webhook:SendCustomEvent(\"ðŸŽ‰ New Achievement!\", data, self.channels.ACHIEVEMENTS)\nend\n\nfunction MessageRouter:SendError(error, context)\n    local data = {\n        [\"âŒ Error\"] = tostring(error),\n        [\"ðŸ“ Context\"] = tostring(context),\n        [\"ðŸ†” Server\"] = game.JobId,\n        [\"â° Time\"] = os.date(\"%H:%M:%S UTC\")\n    }\n    return self.webhook:SendCustomEvent(\"ðŸš¨ Error Report\", data, self.channels.ERRORS)\nend\n\nfunction MessageRouter:SendAdminAlert(title, data)\n    return self.webhook:SendCustomEvent(\"ðŸ”” \" .. title, data, self.channels.ADMIN_GENERAL)\nend\n\n-- Usage examples\nMessageRouter:SendToGeneral(\"ðŸš€ Server started!\")\n\n-- Player events\ngame.Players.PlayerAdded:Connect(function(player)\n    MessageRouter:SendPlayerEvent(player, \"join\")\nend)\n\ngame.Players.PlayerRemoving:Connect(function(player)\n    MessageRouter:SendPlayerEvent(player, \"leave\")\nend)\n\n-- Game events\nMessageRouter:SendGameEvent(\"ðŸ‰ Boss Spawned\", {\n    [\"Boss\"] = \"Dragon King\",\n    [\"Location\"] = \"Central Arena\",\n    [\"Difficulty\"] = \"Legendary\",\n    [\"Rewards\"] = \"Epic Loot + 1000 XP\"\n})\n\n-- Achievements\nlocal function onPlayerAchievement(player, achievementName)\n    MessageRouter:SendAchievement(player, {\n        name = achievementName,\n        rarity = \"Rare\"\n    })\nend\n\n-- Error handling\nlocal function handleError(err, context)\n    MessageRouter:SendError(err, context)\nend\n```"
        },
        {
          "title": "Economy Tracking System",
          "content": "Track in-game economy events and transactions:\n\n```lua\nlocal WebhookLib = require(game.ReplicatedStorage.WebhookLib)\nlocal MarketplaceService = game:GetService(\"MarketplaceService\")\n\nlocal webhook = WebhookLib.new(\"YOUR_WEBHOOK_URL\", {\n    username = \"ðŸ’° Economy Tracker\",\n    queue_rate_limit = 2,\n    default_color = 0xFFD700  -- Gold color\n})\n\nlocal ECONOMY_THREAD = \"123456789012345678\"\n\n-- Economy event tracker\nlocal EconomyTracker = {\n    webhook = webhook,\n    threadId = ECONOMY_THREAD,\n    \n    -- Daily stats\n    dailyStats = {\n        transactions = 0,\n        revenue = 0,\n        itemsSold = 0,\n        topItems = {}\n    }\n}\n\n-- Track robux purchases\nMarketplaceService.ProcessReceipt = function(receiptInfo)\n    pcall(function()\n        local player = game.Players:GetPlayerByUserId(receiptInfo.PlayerId)\n        if player then\n            EconomyTracker:TrackPurchase({\n                player = player,\n                productId = receiptInfo.ProductId,\n                robux = receiptInfo.CurrencySpent,\n                receiptId = receiptInfo.PurchaseId\n            })\n        end\n    end)\n    \n    return Enum.ProductPurchaseDecision.PurchaseGranted\nend\n\n-- Track in-game currency transactions\nfunction EconomyTracker:TrackTransaction(data)\n    local transactionData = {\n        [\"ðŸ‘¤ Player\"] = data.player.DisplayName,\n        [\"ðŸ’Ž Item\"] = data.itemName or \"Unknown\",\n        [\"ðŸ’° Cost\"] = tostring(data.cost) .. \" \" .. (data.currency or \"coins\"),\n        [\"ðŸ“Š Type\"] = data.transactionType or \"Purchase\",\n        [\"ðŸ†” Transaction\"] = data.transactionId or \"N/A\",\n        [\"â° Time\"] = os.date(\"%H:%M:%S\")\n    }\n    \n    -- Determine embed color based on transaction type\n    local color = 0x00FF00  -- Green for purchases\n    if data.transactionType == \"Sale\" then\n        color = 0xFF6B00  -- Orange for sales\n    elseif data.transactionType == \"Trade\" then\n        color = 0x0099FF  -- Blue for trades\n    end\n    \n    local embed = {\n        title = \"ðŸ’° Economy Transaction\",\n        color = color,\n        fields = {},\n        timestamp = os.date(\"!%Y-%m-%dT%H:%M:%SZ\")\n    }\n    \n    -- Convert data to embed fields\n    for name, value in pairs(transactionData) do\n        table.insert(embed.fields, {\n            name = name,\n            value = value,\n            inline = true\n        })\n    end\n    \n    self.webhook:SendEmbed(embed, self.threadId)\n    \n    -- Update daily stats\n    self.dailyStats.transactions = self.dailyStats.transactions + 1\nend\n\n-- Track robux purchases\nfunction EconomyTracker:TrackPurchase(data)\n    local purchaseData = {\n        [\"ðŸ‘¤ Player\"] = data.player.DisplayName,\n        [\"ðŸ›’ Product ID\"] = tostring(data.productId),\n        [\"ðŸ’Ž Robux Spent\"] = tostring(data.robux),\n        [\"ðŸ†” Receipt\"] = data.receiptId,\n        [\"â° Time\"] = os.date(\"%H:%M:%S UTC\")\n    }\n    \n    self.webhook:SendCustomEvent(\"ðŸ’³ Robux Purchase\", purchaseData, self.threadId)\n    \n    -- Update revenue stats\n    self.dailyStats.revenue = self.dailyStats.revenue + data.robux\nend\n\n-- Track rare item events\nfunction EconomyTracker:TrackRareItem(data)\n    local rareItemData = {\n        [\"ðŸ‘¤ Player\"] = data.player.DisplayName,\n        [\"âœ¨ Item\"] = data.itemName,\n        [\"ðŸŽ² Rarity\"] = data.rarity or \"Legendary\",\n        [\"ðŸ“ˆ Value\"] = tostring(data.estimatedValue or \"Unknown\"),\n        [\"ðŸŽ¯ Source\"] = data.source or \"Unknown\",\n        [\"â° Time\"] = os.date(\"%H:%M:%S\")\n    }\n    \n    self.webhook:SendCustomEvent(\"ðŸŒŸ Rare Item Obtained!\", rareItemData, self.threadId)\nend\n\n-- Daily summary report\nfunction EconomyTracker:SendDailySummary()\n    local summaryData = {\n        [\"ðŸ“Š Total Transactions\"] = tostring(self.dailyStats.transactions),\n        [\"ðŸ’° Robux Revenue\"] = tostring(self.dailyStats.revenue),\n        [\"ðŸ›’ Items Sold\"] = tostring(self.dailyStats.itemsSold),\n        [\"ðŸ“… Date\"] = os.date(\"%Y-%m-%d\"),\n        [\"ðŸ• Generated At\"] = os.date(\"%H:%M:%S UTC\")\n    }\n    \n    self.webhook:SendCustomEvent(\"ðŸ“ˆ Daily Economy Report\", summaryData, self.threadId)\n    \n    -- Reset daily stats\n    self.dailyStats = {\n        transactions = 0,\n        revenue = 0,\n        itemsSold = 0,\n        topItems = {}\n    }\nend\n\n-- Schedule daily summary\ntask.spawn(function()\n    while true do\n        task.wait(86400)  -- 24 hours\n        EconomyTracker:SendDailySummary()\n    end\nend)\n\n-- Example usage\nlocal function simulateTransaction()\n    EconomyTracker:TrackTransaction({\n        player = game.Players:FindFirstChild(\"TestPlayer\"),\n        itemName = \"Legendary Sword\",\n        cost = 5000,\n        currency = \"gold\",\n        transactionType = \"Purchase\",\n        transactionId = \"TXN_\" .. tostring(math.random(100000, 999999))\n    })\nend\n\nprint(\"Economy tracking system initialized\")\n```"
        }
      ]
    },
    {
      "id": "troubleshooting",
      "title": "Troubleshooting",
      "content": "Common issues, error messages, and their solutions when using WebhookLib.",
      "subsections": [
        {
          "title": "Setup Issues",
          "content": "**Error: \"HTTP requests are disabled\"**\n\n*Cause:* Game settings don't allow HTTP requests\n\n*Solution:*\n1. Go to your game's Configure page\n2. Navigate to Settings > Security\n3. Enable \"Allow HTTP Requests\"\n4. Save changes and restart servers\n\n---\n\n**Error: \"DataStore: UNAVAILABLE\"**\n\n*Cause:* DataStore API is disabled or unavailable\n\n*Solution:*\n1. Check game settings for DataStore access\n2. Ensure the game is published (not just saved)\n3. DataStore may be temporarily down - check Roblox status\n\n---\n\n**Error: \"Invalid webhook URL\"**\n\n*Cause:* Webhook URL is malformed or incorrect\n\n*Solution:*\n1. Verify the webhook URL format\n2. Ensure you're using a Roblox-compatible proxy\n3. Test the URL in a web browser"
        },
        {
          "title": "Connection Issues",
          "content": "**Error: \"HTTP 404 (Not Found)\"**\n\n*Cause:* Webhook doesn't exist or URL is wrong\n\n*Solutions:*\n- Double-check the webhook URL\n- Verify the webhook hasn't been deleted in Discord\n- Ensure the webhook token is correct\n- Try creating a new webhook\n\n---\n\n**Error: \"HTTP 401 (Unauthorized)\"**\n\n*Cause:* Invalid webhook token or permissions\n\n*Solutions:*\n- Regenerate the webhook URL in Discord\n- Check if the webhook was deleted and recreated\n- Verify channel permissions\n\n---\n\n**Error: \"HTTP 403 (Forbidden)\"**\n\n*Cause:* Bot lacks permissions or channel restrictions\n\n*Solutions:*\n- Check Discord channel permissions\n- Verify the webhook has \"Send Messages\" permission\n- Ensure the channel allows webhooks"
        },
        {
          "title": "Message Issues",
          "content": "**Messages not appearing in Discord**\n\n*Possible causes and solutions:*\n\n1. **Rate limiting**\n   - Enable queue system: `queue_rate_limit = 2`\n   - Check debug logs for rate limit messages\n\n2. **Content filtering**\n   - Discord may filter certain content\n   - Try sending a simple \"test\" message\n\n3. **Thread issues**\n   - Verify thread ID is correct\n   - Ensure thread still exists\n   - Check thread permissions\n\n4. **Network issues**\n   - Check if other HTTP requests work\n   - Try from Studio vs live servers\n\n---\n\n**Messages appearing out of order**\n\n*Cause:* Multiple requests sent simultaneously\n\n*Solution:* Enable queue system with rate limiting\n```lua\nqueue_rate_limit = 2  -- Forces sequential sending\n```"
        },
        {
          "title": "Queue Problems",
          "content": "**Queue growing too large**\n\n*Symptoms:* High memory usage, slow performance\n\n*Solutions:*\n- Reduce message frequency\n- Increase rate limit if safe\n- Monitor queue size: `webhook:GetQueueSize()`\n- Implement message priority/filtering\n\n```lua\n-- Monitor queue size\ntask.spawn(function()\n    while true do\n        local size = webhook:GetQueueSize()\n        if size > 100 then\n            warn(\"Queue size is large:\", size)\n        end\n        task.wait(10)\n    end\nend)\n```\n\n---\n\n**Messages not being queued**\n\n*Cause:* Queue not enabled or configured incorrectly\n\n*Solutions:*\n```lua\n-- Ensure queue is enabled\nqueue_enabled = true\n-- OR\nqueue_rate_limit = 2  -- Auto-enables queue\n\n-- Check at runtime\nprint(\"Queue enabled:\", webhook:IsQueueEnabled())\n```"
        },
        {
          "title": "Message Tracking Issues",
          "content": "**Message IDs not being stored**\n\n*Cause:* Message tracking not enabled\n\n*Solution:*\n```lua\nlocal webhook = WebhookLib.new(\"URL\", {\n    track_message_ids = true  -- Enable tracking\n})\n\n-- Or enable at runtime\nwebhook:EnableMessageTracking(true)\n```\n\n---\n\n**Edit/Delete operations failing**\n\n*Common issues:*\n\n1. **Message too old**\n   - Discord limits editing old messages\n   - Edit within 15 minutes for best results\n\n2. **Invalid message ID**\n   - Verify the message ID is correct\n   - Check if message was deleted\n\n3. **Message not from webhook**\n   - Only webhook messages can be edited\n   - Regular bot messages cannot be edited via webhook\n\n```lua\n-- Debug message operations\nlocal function debugEditMessage(messageId, content)\n    local success = webhook:EditMessage(messageId, content)\n    if success then\n        print(\"Edit queued successfully\")\n    else\n        warn(\"Edit failed - check message ID and permissions\")\n    end\nend\n```"
        },
        {
          "title": "Performance Issues",
          "content": "**High memory usage**\n\n*Causes and solutions:*\n\n1. **Large message queue**\n   - Monitor: `webhook:GetQueueSize()`\n   - Reduce message frequency\n   - Increase processing rate\n\n2. **Too many stored message IDs**\n   - Reduce: `max_stored_messages = 50`\n   - Clear periodically: `webhook:ClearStoredMessages()`\n\n3. **Avatar cache bloat**\n   - Reduce TTL: `cache_ttl_avatar = 300`\n   - Cache automatically expires\n\n---\n\n**Slow message delivery**\n\n*Causes and solutions:*\n\n1. **Rate limiting too restrictive**\n   - Increase: `queue_rate_limit = 3`\n   - Balance with Discord limits\n\n2. **Network issues**\n   - Check server connection\n   - Test with simple messages\n\n3. **Queue backup**\n   - Monitor queue size\n   - Reduce message volume\n\n```lua\n-- Performance monitoring\nlocal function monitorPerformance()\n    print(\"=== WebhookLib Status ===\")\n    print(\"Queue enabled:\", webhook:IsQueueEnabled())\n    print(\"Queue size:\", webhook:GetQueueSize())\n    print(\"Message tracking:\", webhook:IsMessageTrackingEnabled())\n    \n    if webhook:IsMessageTrackingEnabled() then\n        local messages = webhook:GetStoredMessages()\n        print(\"Stored messages:\", #messages)\n    end\nend\n\n-- Run every minute\ntask.spawn(function()\n    while true do\n        monitorPerformance()\n        task.wait(60)\n    end\nend)\n```"
        },
        {
          "title": "Debug Mode",
          "content": "Enable debug mode to diagnose issues:\n\n```lua\nlocal webhook = WebhookLib.new(\"YOUR_URL\", {\n    debug = true\n})\n\n-- Or enable at runtime\nwebhook:EnableDebug(true)\n```\n\n**Debug output includes:**\n- Initialization status\n- Queue operations and size\n- HTTP request/response details\n- Rate limit information\n- DataStore operations\n- Message ID tracking events\n- Error messages with context\n\n**Reading debug output:**\n\n```\n[WebhookLib] WebhookLib initialized successfully\n[WebhookLib] Queue system: ENABLED\n[WebhookLib] Rate limit: 2 requests/second\n[WebhookLib] DataStore: AVAILABLE\n[WebhookLib] Queued text message: Hello Discord!\n[WebhookLib] HTTP response status: 200\n[WebhookLib] Request completed successfully\n[WebhookLib] Message ID received: 123456789\n```\n\n**Common debug patterns:**\n- `HTTP response status: 429` = Rate limited\n- `DataStore: UNAVAILABLE` = DataStore issues\n- `Queue size: X` = Monitor queue growth\n- `Rate limiting: waiting X seconds` = Automatic rate limit handling"
        }
      ]
    },
    {
      "id": "best-practices",
      "title": "Best Practices",
      "content": "Recommended practices for reliable, efficient, and maintainable webhook implementations.",
      "subsections": [
        {
          "title": "Production Deployment",
          "content": "**Essential production settings:**\n\n```lua\nlocal webhook = WebhookLib.new(\"YOUR_URL\", {\n    username = \"ðŸŽ® Your Game\",\n    debug = false,  -- IMPORTANT: Disable in production\n    queue_rate_limit = 2,  -- Prevent Discord rate limits\n    filter_profanity = true,  -- Clean content\n    max_retries = 5,  -- Handle network issues\n    track_message_ids = true,  -- Enable message management\n    max_stored_messages = 100  -- Reasonable memory usage\n})\n```\n\n**Error handling pattern:**\n```lua\n-- ALWAYS wrap webhook calls in pcall\nlocal function safeWebhookCall(func, ...)\n    local success, result = pcall(func, ...)\n    if not success then\n        warn(\"Webhook error:\", result)\n        -- Optional: Log to alternative system\n    end\n    return success, result\nend\n\n-- Usage\nsafeWebhookCall(webhook.SendMessage, webhook, \"Safe message\")\n```\n\n**Resource management:**\n```lua\n-- Graceful shutdown\ngame:BindToClose(function()\n    pcall(function()\n        webhook:SendMessage(\"ðŸ”„ Server restarting...\")\n        webhook:Shutdown()\n        task.wait(3)  -- Allow final messages\n    end)\nend)\n```"
        },
        {
          "title": "Message Organization",
          "content": "**Use threads for organization:**\n\n```lua\n-- Define thread purposes clearly\nlocal THREADS = {\n    PLAYERS = \"111111111111111111\",  -- Join/leave events\n    GAME_EVENTS = \"222222222222222222\",  -- Game-specific events\n    ACHIEVEMENTS = \"333333333333333333\",  -- Player achievements\n    ERRORS = \"444444444444444444\",  -- Error logging\n    ADMIN = \"555555555555555555\"  -- Administrative alerts\n}\n\n-- Route messages appropriately\nwebhook:SendJoinMessage(player, THREADS.PLAYERS)\nwebhook:SendCustomEvent(\"Boss Defeated\", data, THREADS.GAME_EVENTS)\n```\n\n**Message priority system:**\n```lua\n-- Critical messages (errors, security)\nlocal function sendCritical(message, data)\n    pcall(function()\n        webhook:SendCustomEvent(\"ðŸš¨ \" .. message, data, THREADS.ADMIN)\n    end)\nend\n\n-- Standard messages (game events)\nlocal function sendStandard(message, data, thread)\n    pcall(function()\n        webhook:SendCustomEvent(message, data, thread)\n    end)\nend\n\n-- Low priority (player stats)\nlocal function sendLowPriority(message, data, thread)\n    -- Maybe queue these or send less frequently\n    if webhook:GetQueueSize() < 20 then  -- Only if queue not busy\n        pcall(function()\n            webhook:SendCustomEvent(message, data, thread)\n        end)\n    end\nend\n```"
        },
        {
          "title": "Performance Optimization",
          "content": "**Rate limiting strategy:**\n\n```lua\n-- Conservative for high-traffic games\nqueue_rate_limit = 1  -- 1 message per second\n\n-- Moderate for most games (recommended)\nqueue_rate_limit = 2  -- 2 messages per second\n\n-- Aggressive for low-traffic games\nqueue_rate_limit = 5  -- 5 messages per second\n```\n\n**Memory management:**\n```lua\n-- Reasonable limits\nmax_stored_messages = 50  -- For small games\nmax_stored_messages = 100 -- For medium games\nmax_stored_messages = 200 -- For large games only\n\n-- Periodic cleanup\ntask.spawn(function()\n    while true do\n        task.wait(1800)  -- Every 30 minutes\n        if webhook:IsMessageTrackingEnabled() then\n            local messages = webhook:GetStoredMessages()\n            if #messages > 150 then  -- If too many stored\n                webhook:ClearStoredMessages()\n                print(\"Cleared stored message IDs\")\n            end\n        end\n    end\nend)\n```\n\n**Avatar cache optimization:**\n```lua\n-- Adjust based on player turnover\ncache_ttl_avatar = 300   -- 5 min for high turnover\ncache_ttl_avatar = 900   -- 15 min for moderate turnover\ncache_ttl_avatar = 1800  -- 30 min for stable player base\n```"
        },
        {
          "title": "Content Management",
          "content": "**Profanity filtering:**\n\n```lua\nlocal webhook = WebhookLib.new(\"YOUR_URL\", {\n    filter_profanity = true,\n    banned_words = {\n        \"exploit\", \"hack\", \"cheat\",  -- Game-specific terms\n        \"discord.gg\", \"youtube.com\"  -- Prevent advertising\n    }\n})\n```\n\n**Content formatting:**\n```lua\n-- Use emojis for visual appeal\nlocal EMOJIS = {\n    success = \"âœ…\",\n    error = \"âŒ\", \n    warning = \"âš ï¸\",\n    info = \"â„¹ï¸\",\n    player = \"ðŸ‘¤\",\n    game = \"ðŸŽ®\"\n}\n\n-- Format messages consistently\nlocal function formatGameEvent(eventType, data)\n    local emoji = EMOJIS[eventType] or EMOJIS.info\n    local title = emoji .. \" \" .. (data.title or \"Game Event\")\n    return title\nend\n\n-- Use consistent field naming\nlocal eventData = {\n    [\"ðŸ‘¤ Player\"] = player.DisplayName,  -- Always use emojis\n    [\"ðŸŽ¯ Action\"] = \"Achievement Unlocked\",\n    [\"â° Time\"] = os.date(\"%H:%M:%S\"),\n    [\"ðŸ†” Server\"] = game.JobId:sub(1, 8)  -- Truncate long IDs\n}\n```"
        },
        {
          "title": "Security Considerations",
          "content": "**Webhook URL security:**\n\n```lua\n-- Store webhook URL securely\n-- Option 1: Module with restricted access\nlocal WebhookConfig = {\n    URL = \"YOUR_WEBHOOK_URL_HERE\",\n    BACKUP_URL = \"BACKUP_WEBHOOK_URL\"  -- Fallback option\n}\n\n-- Option 2: Environment-based (if available)\n-- local WEBHOOK_URL = os.getenv(\"DISCORD_WEBHOOK_URL\")\n```\n\n**Data sanitization:**\n```lua\n-- Always sanitize user input\nlocal function sanitizeUserInput(input)\n    if not input then return \"Unknown\" end\n    \n    local sanitized = tostring(input)\n    -- Remove potential markdown/mentions\n    sanitized = sanitized:gsub(\"[@#`*_~|]\", \"\")\n    -- Limit length\n    sanitized = sanitized:sub(1, 100)\n    return sanitized\nend\n\n-- Use in custom events\nlocal function sendPlayerEvent(player, eventType, data)\n    local sanitizedData = {\n        [\"Player\"] = sanitizeUserInput(player.DisplayName),\n        [\"Event\"] = sanitizeUserInput(eventType)\n    }\n    \n    -- Add other data with sanitization\n    for key, value in pairs(data or {}) do\n        sanitizedData[sanitizeUserInput(key)] = sanitizeUserInput(value)\n    end\n    \n    webhook:SendCustomEvent(\"Player Event\", sanitizedData)\nend\n```\n\n**Rate limiting protection:**\n```lua\n-- Implement additional protection for high-frequency events\nlocal lastMessageTime = {}\nlocal MIN_MESSAGE_INTERVAL = 5  -- seconds\n\nlocal function rateLimitedSend(key, messageFunc)\n    local now = tick()\n    local lastTime = lastMessageTime[key] or 0\n    \n    if (now - lastTime) >= MIN_MESSAGE_INTERVAL then\n        lastMessageTime[key] = now\n        pcall(messageFunc)\n    else\n        print(\"Rate limited message:\", key)\n    end\nend\n\n-- Usage\nrateLimitedSend(\"player_death_\" .. player.UserId, function()\n    webhook:SendCustomEvent(\"Player Death\", data)\nend)\n```"
        },
        {
          "title": "Monitoring & Maintenance",
          "content": "**Health monitoring:**\n\n```lua\n-- Health check system\nlocal HealthMonitor = {\n    webhook = webhook,\n    lastSuccessTime = tick(),\n    errorCount = 0,\n    maxErrors = 10\n}\n\nfunction HealthMonitor:recordSuccess()\n    self.lastSuccessTime = tick()\n    self.errorCount = 0\nend\n\nfunction HealthMonitor:recordError()\n    self.errorCount = self.errorCount + 1\n    \n    if self.errorCount >= self.maxErrors then\n        warn(\"Webhook system appears to be failing\")\n        -- Could disable webhook temporarily or alert admins\n    end\nend\n\nfunction HealthMonitor:checkHealth()\n    local timeSinceSuccess = tick() - self.lastSuccessTime\n    \n    if timeSinceSuccess > 300 then  -- 5 minutes\n        warn(\"No successful webhook messages in 5 minutes\")\n        return false\n    end\n    \n    if self.errorCount > 5 then\n        warn(\"High error rate in webhook system\")\n        return false\n    end\n    \n    return true\nend\n\n-- Regular health checks\ntask.spawn(function()\n    while true do\n        task.wait(60)  -- Check every minute\n        HealthMonitor:checkHealth()\n    end\nend)\n```\n\n**Statistics tracking:**\n```lua\n-- Simple statistics\nlocal WebhookStats = {\n    messagesSent = 0,\n    messagesEdited = 0,\n    messagesDeleted = 0,\n    errors = 0,\n    startTime = tick()\n}\n\n-- Wrap webhook methods to track stats\nlocal originalSendMessage = webhook.SendMessage\nwebhook.SendMessage = function(self, ...)\n    local success = originalSendMessage(self, ...)\n    if success then\n        WebhookStats.messagesSent = WebhookStats.messagesSent + 1\n    else\n        WebhookStats.errors = WebhookStats.errors + 1\n    end\n    return success\nend\n\n-- Daily statistics report\nlocal function sendDailyStats()\n    local uptime = tick() - WebhookStats.startTime\n    local hours = math.floor(uptime / 3600)\n    \n    webhook:SendCustomEvent(\"ðŸ“Š Daily Stats\", {\n        [\"ðŸ“¤ Messages Sent\"] = tostring(WebhookStats.messagesSent),\n        [\"âœï¸ Messages Edited\"] = tostring(WebhookStats.messagesEdited),\n        [\"ðŸ—‘ï¸ Messages Deleted\"] = tostring(WebhookStats.messagesDeleted),\n        [\"âŒ Errors\"] = tostring(WebhookStats.errors),\n        [\"â±ï¸ Uptime\"] = tostring(hours) .. \" hours\",\n        [\"ðŸ“ˆ Success Rate\"] = string.format(\"%.1f%%\", \n            (WebhookStats.messagesSent / math.max(1, WebhookStats.messagesSent + WebhookStats.errors)) * 100)\n    })\nend\n```"
        }
      ]
    }
  ]
}
